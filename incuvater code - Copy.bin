//motor

#include <Wire.h>
#include <RTClib.h>

RTC_DS3231 rtc;



// Motor driver pins
const int motorEnablePin = 5;
const int motorIn1 = 18;
const int motorIn2 = 19;
const int limit1 = 15;
const int limit2 = 2;


void setup() {
  Serial.begin(115200);
  while (!Serial);
  Wire.begin();
  pinMode(limit1, INPUT_PULLUP);
  pinMode(limit2, INPUT_PULLUP);

  // Configure motor driver pins
  pinMode(motorEnablePin, OUTPUT);
  pinMode(motorIn1, OUTPUT);
  pinMode(motorIn2, OUTPUT);
  digitalWrite(motorEnablePin, LOW);

  rtc.begin();
 
}

void loop() {
  DateTime now = rtc.now();

  // Convert 24-hour format to 12-hour format
  int minutes = now.minute();
  int hour = now.hour();
  String meridian = "AM";
  if (hour == 0) {
    hour = 12;
  } else if (hour >= 12) {
    meridian = "PM";
    if (hour > 12) hour -= 12;
  }


 //motor sudle
    if (hour == 12 && minutes == 00 ) {
      motor();

   delay(90000);
   }

   if (hour==1 && minutes==30 ) {
     motor();
   delay(90000);
   }

   if (hour==3 && now.minute()==00 ) {
      motor();
   delay(90000);
   }
   if (hour==4 && minutes==30 ) {
     motor();
   delay(90000);
   }
   if (hour==6 && now.minute()==00 ) {
    motor();
   delay(90000);
   }
   if (hour==7 && minutes==30 ) {
    motor();
   delay(90000);
   }
   if (hour==9 && minutes==00 ) {
    motor();
   delay(90000);
   }
   
   if (hour==10 && minutes==30 ) {
    motor();
   delay(90000);

   }





}

void motor() {
  digitalWrite(motorEnablePin, HIGH);  // Enable motor

  if (digitalRead(limit1) == LOW) {  // If limit switch 1 is LOW (active)
    while (digitalRead(limit2) == HIGH) {  // Move until limit switch 2 is triggered
      digitalWrite(motorIn1, HIGH);
      digitalWrite(motorIn2, LOW);
      delay(2000);
    }
  } 
  else {
    while (digitalRead(limit1) == HIGH) {  // Move until limit switch 1 is triggered
      digitalWrite(motorIn1, LOW);
      digitalWrite(motorIn2, HIGH);
      delay(2000);
    }
  }

  digitalWrite(motorEnablePin, LOW);  // Disable motor after operation
  digitalWrite(motorIn1, LOW);
  digitalWrite(motorIn2, LOW);
  delay(2000);
}

// Sht3x

#include <Arduino.h>
#include <Wire.h>
#include <ArtronShop_SHT3x.h>
#include <LiquidCrystal_I2C.h>

#define MIST_MAKER 4      // Pin for mist maker relay/MOSFET
#define BTN_UP 12         // Button to increase humidity threshold
#define BTN_DOWN 14       // Button to decrease humidity threshold

ArtronShop_SHT3x sht3x(0x44, &Wire);
LiquidCrystal_I2C lcd(0x27, 16, 2);  // Adjust address if necessary

float humidityThreshold = 60.0;  // Default threshold (adjustable)

void setup() {
  Serial.begin(115200);
  Wire.begin();
  lcd.init();
  lcd.backlight();

  pinMode(MIST_MAKER, OUTPUT);
  pinMode(BTN_UP, INPUT_PULLUP);
  pinMode(BTN_DOWN, INPUT_PULLUP);

  while (!sht3x.begin()) {
    Serial.println("SHT3x not found !");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("SHT3x Not Found!");
    delay(1000);
  }
}

void loop() {
  if (sht3x.measure()) {
    float humidity = sht3x.humidity();
    float temperature = sht3x.temperature();

    // Display on LCD
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Te:");
    lcd.print(temperature, 1);
    
    lcd.setCursor(0, 1);
    lcd.print("H:");
    lcd.print(humidity, 1);
    lcd.print("% T:");
    lcd.print(humidityThreshold, 1);

    // Humidity Control Logic
    if (humidity < humidityThreshold) {
      digitalWrite(MIST_MAKER, HIGH);  // Turn ON mist maker
      Serial.println("Mist Maker ON");
    } else {
      digitalWrite(MIST_MAKER, LOW);   // Turn OFF mist maker
      Serial.println("Mist Maker OFF");
    }
  } else {
    Serial.println("SHT3x read error");
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("SHT3x Read Error");
  }

  // Check Button Presses for Threshold Adjustment
  if (digitalRead(BTN_UP) == LOW) {
    humidityThreshold += 1.0;
    Serial.println("Threshold Increased!");
    delay(300);  // Debounce
  }

  if (digitalRead(BTN_DOWN) == LOW) {
    humidityThreshold -= 1.0;
    Serial.println("Threshold Decreased!");
    delay(300);  // Debounce
  }

  delay(1000);
}


// time

#include <Wire.h>
#include <RTClib.h>
#include <WiFi.h>
#include <WiFiManager.h>
#include <NTPClient.h>
#include <WiFiUdp.h>

#define BUTTON_PIN 18 // Button to manually sync time
#define HOTSPOT_TRIGGER_PIN 0 // IO0 for WiFiManager setup mode

RTC_DS3231 rtc;
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", 6 * 3600, 60000); // GMT+6 for Bangladesh
WiFiManager wifiManager;

void setup() {
  Serial.begin(115200);
  while (!Serial);
  Wire.begin();

  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(HOTSPOT_TRIGGER_PIN, INPUT_PULLUP);

  if (!rtc.begin()) {
    Serial.println("Couldn't find RTC");
  }

  
}

void loop() {
  if (digitalRead(BUTTON_PIN) == LOW) { // Button pressed
    Serial.println("Button Pressed: Connecting to WiFi and Syncing Time...");
    connectToWiFiAndSyncTime();
  }


  // Check if the button is pressed for 5 seconds to enter WiFiManager mode
  if (digitalRead(HOTSPOT_TRIGGER_PIN) == LOW) {
    Serial.println("Hold detected. Entering WiFi setup mode...");
    delay(5000);
    if (digitalRead(HOTSPOT_TRIGGER_PIN) == LOW) {
      Serial.println("Starting WiFiManager portal...");
      wifiManager.startConfigPortal("ESP32_Setup");
    }
    // Auto-connect to saved WiFi credentials
  wifiManager.autoConnect("ESP32_AutoConnect");
  Serial.println("Connected to WiFi!");
  }

  DateTime now = rtc.now();
  int hour = now.hour();
  String meridian = "AM";
  if (hour == 0) {
    hour = 12;
  } else if (hour >= 12) {
    meridian = "PM";
    if (hour > 12) hour -= 12;
  }

  Serial.print(now.year());
  Serial.print('/');
  Serial.print(now.month());
  Serial.print('/');
  Serial.print(now.day());
  Serial.print(") ");
  Serial.print(hour);
  Serial.print(':');
  Serial.print(now.minute());
  Serial.print(':');
  Serial.print(now.second());
  Serial.print(" ");
  Serial.println(meridian);

  Serial.print("Temperature: ");
  Serial.print(rtc.getTemperature());
  Serial.println(" C");

  Serial.println();
  delay(500);
}

void connectToWiFiAndSyncTime() {
  if (WiFi.status() != WL_CONNECTED) {
    WiFi.begin();
    unsigned long startTime = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - startTime < 10000) {
      delay(500);
      Serial.print(".");
    }
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nConnected to WiFi! Updating RTC time...");
    timeClient.begin();
    timeClient.update();
    unsigned long epochTime = timeClient.getEpochTime();
    DateTime ntpTime(epochTime);
    rtc.adjust(ntpTime);
    Serial.println("RTC Updated!");
  } else {
    Serial.println("\nFailed to connect to WiFi.");
  }
}


